{"title":"c语言可变参数","uid":"891368c40364640d375bd2bab3f27dc8","slug":"c语言可变参数","date":"2022-05-29T10:12:50.000Z","updated":"2022-05-29T10:38:15.285Z","comments":true,"path":"api/articles/c语言可变参数.json","keywords":null,"cover":"https://tse4-mm.cn.bing.net/th/id/OIP-C.eqV6_Q73ibrBxnlTkLLpJAAAAA","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n<h1 id=\"c语言可变参数\"><a href=\"#c语言可变参数\" class=\"headerlink\" title=\"c语言可变参数\"></a>c语言可变参数</h1><p>在定义一个函数的时候, 有些时候不能确定会有几个参数, 譬如printf这个函数, c语言中我们可以利用一系列宏来实现可变参数</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>利用最后一个确定参数的位置找到下一个可变参数的位置, 这里涉及到<a href=\"https://www.bilibili.com/video/BV1Vt4y1m7DP\">内存对齐</a>的问题. c中利用宏<code>_INTSIZEOF</code>完成内存对齐操作.</p>\n<h2 id=\"va-list-va-start-va-arg-va-end…\"><a href=\"#va-list-va-start-va-arg-va-end…\" class=\"headerlink\" title=\"va_list, va_start, va_arg, va_end…\"></a>va_list, va_start, va_arg, va_end…</h2><p>这里我给出一个例子</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> cnt<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    va_list ap<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">va_start</span><span class=\"token punctuation\">(</span>ap<span class=\"token punctuation\">,</span> cnt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> cnt<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        value <span class=\"token operator\">=</span> <span class=\"token function\">va_arg</span><span class=\"token punctuation\">(</span>ap<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//do something</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">va_end</span><span class=\"token punctuation\">(</span>ap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>va_list: 不同平台实现不同</li>\n<li>va_arg(ap, arg_type): 迭代ap</li>\n<li>va_end(ap): 置零</li>\n</ul>\n<p>相关应用可以查看asprintf的实现</p>\n","feature":true,"text":" c语言可变参数在定义一个函数的时候, 有些时候不能确定会有几个参数, 譬如printf这个函数, c语言中我们可以利用一系列宏来实现可变参数 原理利用最后一个确定参数的位置找到下一个可变参数的位置, 这里涉及到内存对齐的问题. c中利用宏_INTSIZEOF完成内存对齐操作. ...","link":"","photos":[],"count_time":{"symbolsCount":492,"symbolsTime":"1 mins."},"categories":[{"name":"c","slug":"c","count":1,"path":"api/categories/c.json"}],"tags":[{"name":"可变参数","slug":"可变参数","count":1,"path":"api/tags/可变参数.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#c%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">c语言可变参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#va-list-va-start-va-arg-va-end%E2%80%A6\"><span class=\"toc-text\">va_list, va_start, va_arg, va_end…</span></a></li></ol></li></ol>","author":{"name":"CYR","slug":"blog-author","avatar":"/static/img/avatar.jpg","link":"/","description":"一个学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"c++  stl","uid":"de220b48c36880e94f5eb744b982c625","slug":"cppstl","date":"2022-04-23T12:27:30.000Z","updated":"2022-06-03T16:26:15.477Z","comments":true,"path":"api/articles/cppstl.json","keywords":null,"cover":"/img/cover/cppstl.png","text":" STLtemplate template demo template&lt;typename T> T square(T x)&#123; return x * x; &#125; 大大减少了代码量, 不必为了多种数据类型创建相似的函数, 模板函数可以自动推导实参类型, 但是模...","link":"","photos":[],"count_time":{"symbolsCount":859,"symbolsTime":"1 mins."},"categories":[{"name":"cpp","slug":"cpp","count":1,"path":"api/categories/cpp.json"}],"tags":[{"name":"stl","slug":"stl","count":1,"path":"api/tags/stl.json"}],"author":{"name":"CYR","slug":"blog-author","avatar":"/static/img/avatar.jpg","link":"/","description":"一个学生","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}