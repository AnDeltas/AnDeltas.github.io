[{"id":"a7aec79676dfc3a912f876c98e4616cf","title":"从递归到非递归","content":"\n\n从递归到非递归运行时栈可以点击这里看一个视频\nfibonacci数列示例:栈帧模拟首先我们需要明确一点, 在使用栈模拟运行时栈时, 我们需要站在汇编语言的角度思考问题, 函数运行过程中产生的临时变量等不能再忽略掉, 需要明确为一条语句.就如下例中的变量t1, t2.好的代码不言自明, 可以看代码了.\ntypedef struct Frame &#123;\n    int pc, n, rv, t1, t2; //pc指示当前栈帧运行到了哪一步\n&#125; Frame; // 一个栈帧, 由于是递归调用, 栈帧的大小就是确定的.\n\n#define call(...) (&#123; *(++top) = (Frame)&#123;.pc = 0, __VA_ARGS__&#125;; &#125;)\n#define goto(loc) (&#123; f->pc = (loc)-1; &#125;)\n#define ret() (&#123; top--; &#125;)\n\nint fibs(int n) &#123;\n    Frame stk[64], *top = stk - 1;\n    int rax = 0; //模拟rax寄存器, 保存函数返回值\n    call(n);\n\n    for (Frame *f; (f = top) >= stk; f->pc++) &#123;\n        //在switch中, 每一个case相当于对应的递归函数中的一行.\n        //但需要注意的是, 临时变量需要显式的表示出来.\n        switch (f->pc) &#123;\n            case 0:\n                if (f->n == 1 || f->n == 2) &#123;\n                    f->rv = 1;\n                    goto(5);\n                &#125;\n                break;\n            case 1:\n                call(f->n - 1);\n                break;\n            case 2:\n                f->t1 = rax;\n                break;\n            case 3:\n                call(f->n - 2);\n                break;\n            case 4:\n                f->t2 = rax;\n                break;\n            case 5:\n                if (f->rv == 0) f->rv = f->t1 + f->t2;\n                rax = f->rv;\n                ret();\n                //由于在递归函数中有两种返回方式, 所以这里需要判断一下是哪一种\n                break;\n        &#125;\n    &#125;\n\n    return rax;\n&#125;\n","slug":"从递归到非递归","date":"2022-06-06T03:10:38.000Z","categories_index":"c","tags_index":"递归","author_index":"CYR"},{"id":"891368c40364640d375bd2bab3f27dc8","title":"c语言可变参数","content":"\n\nc语言可变参数在定义一个函数的时候, 有些时候不能确定会有几个参数, 譬如printf这个函数, c语言中我们可以利用一系列宏来实现可变参数\n原理利用最后一个确定参数的位置找到下一个可变参数的位置, 这里涉及到内存对齐的问题. c中利用宏_INTSIZEOF完成内存对齐操作.\nva_list, va_start, va_arg, va_end…这里我给出一个例子\n#include &lt;stdio.h>\n\nvoid test(int cnt, ...)&#123;\n    va_list ap;\n\n    va_start(ap, cnt);\n    for(int i = 0; i &lt; cnt; i++)&#123;\n        value = va_arg(ap, int);\n        //do something\n    &#125;\n    va_end(ap);\n&#125;\n\nva_list: 不同平台实现不同\nva_arg(ap, arg_type): 迭代ap\nva_end(ap): 置零\n\n相关应用可以查看asprintf的实现\n","slug":"c语言可变参数","date":"2022-05-29T10:12:50.000Z","categories_index":"c","tags_index":"可变参数","author_index":"CYR"},{"id":"de220b48c36880e94f5eb744b982c625","title":"c++  stl","content":"\n\nSTLtemplate\ntemplate demo\n\n\n\n\n\n\n\n\n\ntemplate&lt;typename T>\nT square(T x)&#123;\n    return x * x;\n&#125;\n\n大大减少了代码量, 不必为了多种数据类型创建相似的函数, 模板函数可以自动推导实参类型, 但是模板类能推导, 所以创建模板类实例需要指定T.\n\n\niterator行为类似指针, 通过它能遍历容器\n\n\n\n\n\n\n\n\n\n\nvec.end()未定义, 所以不能访问.\nalgorithms并不直接作用在容器上, 而是为iterator服务.\ncontainers\nSequence containers\nvector \ndeque\nlist\nforward list\narray\n\n\nAssociative containers\nset, multiset\nmap, multimap\n\n\nUnordered containers\nUnordered set/multiset\nUnordered map/multimap\n\n\n\nsequence container\nvec[idx]无范围检查/vec.at(idx)有范围检查, 抛出range_error\n\n遍历for(int i; i &lt; vec.size(): i++)\n    //anything else\n\nfor(auto i = vec.begin(); i != vec.end(); i++)\n    //anything else\n\nfor(auto i : vec) //c++ 11\n    //anything else\n\ncommon member functions\nempty: 判空\nsize\nclear: 清空\nswap:  交换内容物\ninsert\nerase\n\nvector特性\n头插慢\nsearch慢\n\nDeque特性\n中间插入满\nsearch慢\n\nlist特性\n插入快\n不能随机访问\nsearch慢\n\n待更新","slug":"cppstl","date":"2022-04-23T12:27:30.000Z","categories_index":"cpp","tags_index":"stl","author_index":"CYR"},{"id":"1597a415ca82328d83779c59436ff1ef","title":"ip分类和子网掩码","content":"\n\nip分类和子网掩码1. ip地址结构IP地址由32位二进制串构成, 人为的划分成4段并转化为十进制, 方便记忆书写, 如192.168.0.1\n2. ip地址分类传统的方式是分为A/B/C/D/E, 例如对C类IP地址, 以110开头, 后21位为网络号, 剩余部分可以分配为主机号.\n3. 子网掩码用于判断两个ip是否在同一网段. 同样由32位01串构成, 如255.255.0.0构成, 若两个ip地址与子网掩码相与, 得到的值相同, 说明两个ip处于同一网段\n4. 子网划分(假如全都划分在一个网段里太浪费了)例如对C类子网进行再划分为两部分, 子网掩码就是255.255.255.128, 最后八位写成二进制就是10000000, 分成两段之后可用地址分别是0到127, 128到255, 实际上要把主机地址全零和全一的地址去掉, 也就是剩下了1到126, 129到254, 再分别除去一个默认网关就是这两段地址实际可用的主机号数量, 默认网关通常为一个网段的首个主机号.\n","slug":"ip分类和子网掩码","date":"2022-03-13T11:45:04.000Z","categories_index":"计算机网络","tags_index":"ip","author_index":"CYR"},{"id":"3cb78585ebc1a97e25cb5e965d62b8b6","title":"socket详解","content":"socket是什么?当我们在编辑器中写下如下代码\nfrom socket import *\nwith socket(AF_INET, SOCK_STREAM) as dataSocket:\n\tdataSocket.connect((IP, PORT))\n    # AF_INET代表socket讲采用ipv4进行通信\n    # SOCK_STREAM代表采用TCP协议(流式), 如果是UDP协议, 就写成SOCK_DGRAM(数据报)\n打下断点查看dataSocket对象的结构, 会得到如下结果\n&lt;socket.socket fd&#x3D;1276, family&#x3D;AddressFamily.AF_INET, type&#x3D;SocketKind.SOCK_STREAM, proto&#x3D;0, laddr&#x3D;(&#39;127.0.0.1&#39;, 50000), raddr&#x3D;(&#39;127.0.0.1&#39;, 20867)&gt;\n\n\n其中fd就是file descriptor\n\n\n\n\n\n\n\n\n\n\nA file descriptor is a number that uniquely identifies an open file in a computer’s operating system. It describes a data resource, and how that resource may be accessed.\nWhen a program asks to open a file — or another data resource, like a network socket — the kernel:\n\nGrants access.\nCreates an entry in the global file table.\nProvides the software with the location of that entry.\n\nThe descriptor is identified by a unique non-negative integer, such as 0, 12, or 567. At least one file descriptor exists for every open file on the system.\nFile descriptors were first used in Unix, and are used by modern operating systems including Linux, macOS, and BSD. In Microsoft Windows, file descriptors are known as file handles.\nWhen a process makes a successful request to open a file, the kernel returns a file descriptor which points to an entry in the kernel’s global file table. The file table entry contains information such as the inode of the file, byte offset, and the access restrictions for that data stream (read-only, write-only, etc.).\n\n\nfamily则指定了socket所采用的地址类型\ntype则说明了socket是采用的协议(TCP/UDP)\nproto也就是protocal也是说明协议类型\nladdr和raddr分别指明了本机和对方主机的IP和端口号\n\n以上就是socket在python语言中的表现形式, 在不同的编程语言中, socket的实现细节可能有所不同, 但大体形式基本一致. 通过socket, 操作系统向网卡最终能读取到的RAM中写入要传输的信息(除了原始报文外, 要加上一系列控制信息譬如目标的IP和端口号), 并通过网卡推送出去.\nsocket的功能作为传输层向应用层提供服务的接口,不同主机上的进程可以利用socket实现信息上的交流, socket为一系列应用层协议的实现提供了支持. 利用socket, 我们用类似操作文件的方式进行不同主机不同应用进程之间的数据交互, 向下层传递应用层报文. \npython中socket常用方法\nbind: 绑定端口\nlisten: 监听端口\nrecev: 接受信息\naccept: 接受一个连接请求(在此之前有listen)\nsend: 发送信息\nconnect: 请求连接\nclose: 关闭socket(python中通常用with管理socket)\n\n","slug":"socket详解","date":"2022-02-09T12:57:41.000Z","categories_index":"计算机网络","tags_index":"socket","author_index":"CYR"},{"id":"cf34b485e52bf362f60976953dc6221e","title":"socket编程python示例","content":"\n\nsocket编程python示例socket定义socket 是应用层与传输层交互的接口, 本质上讲是一个整数, 从操作系统角度来说是表示两个不同主机上应用进程的关系(IP:Port). socket可以分为TCP socket和UDP socket两种, 前者提供可靠的服务, 后者提供不可靠的服务, 但后者相对前者性能高很多. 可靠意味着接收方收到的消息与发送方发送的消息一致(不丢失,不重复,不乱序). 再从编程语言的角度来讲, socket就是一系列的函数与对象, 利用这些函数与对象, 我们可以完成不同主机上应用进程之间的交互.\npython示例(C/S模式, TCP)\nserverimport socket\nfrom threading import Thread\n\n# 主机地址为空字符串，表示绑定本机所有网络接口ip地址\nIP = ''\n# 端口号\nPORT = 50000\n# 定义一次从socket缓冲区最多读入512个字节数据\nBUFFER = 512\n\n\ndef process_socket(s: socket.socket, address):\n    print(f\"与&#123;address&#125;的连接建立\")\n    with s:\n        while True:\n            try:\n                received = s.recv(BUFFER)\n\n                if not received:\n                    print(f'与&#123;address&#125;的连接断开')\n                    break\n\n                # 读取的字节数据是bytes类型，需要解码为字符串\n                info = received.decode()\n\n                print(f'收到对方信息： &#123;info&#125;')\n            except ConnectionResetError:\n                print(f\"&#123;address&#125;强制断开连接\")\n                return\n\n            # 发送的数据类型必须是bytes，所以要编码\n            c.send(f'服务端接收到了信息 &#123;info&#125;'.encode())\n\n\nif __name__ == '__main__':\n    # 实例化一个socket对象\n    # 参数 AF_INET 表示该socket网络层使用IP协议\n    # 参数 SOCK_STREAM 表示该socket传输层使用TCP协议\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as welcomeSocket:\n\n        # socket绑定地址和端口\n        welcomeSocket.bind((IP, PORT))\n\n        # 使socket处于监听状态，等待客户端的连接请求\n        # 参数 8 表示 最多接受多少个等待连接的客户端\n        welcomeSocket.listen(8)\n        print(f'服务端启动成功，在&#123;PORT&#125;端口等待客户端连接...')\n\n        while True:\n            c, addr = welcomeSocket.accept()\n            print('接受一个客户端连接:', addr)\n            # 用多线程的方式解决server同时只能为一个client服务的问题\n            t = Thread(target=process_socket, args=(c, addr))\n            t.start()\n\n\n\n\nclientfrom socket import *\n\nIP = '127.0.0.1'\nPORT = 50000\nBUFFER = 1024\n\nif __name__ == '__main__':\n\n    # 实例化一个socket对象，指明协议\n    with socket(AF_INET, SOCK_STREAM) as dataSocket:\n\n        # 连接服务端socket\n        try:\n            dataSocket.connect((IP, PORT))\n        except ConnectionRefusedError:\n            print('服务器拒绝连接')\n            exit(0)\n\n        while True:\n            # 从终端读入用户输入的字符串\n            toSend = input('>>> ')\n            if toSend == 'exit':\n                break\n            # 发送消息，也要编码为 bytes\n            dataSocket.send(toSend.encode())\n\n            # 等待接收服务端的消息\n            received = dataSocket.recv(BUFFER)\n            # 如果返回空bytes，表示对方关闭了连接\n            if not received:\n                break\n            # 打印读取的信息\n            print(received.decode())\n\n\n","slug":"socket编程python示例","date":"2022-02-07T13:41:18.000Z","categories_index":"python","tags_index":"socket","author_index":"CYR"},{"id":"47eae1e4716d0028cdae517170b1e6a4","title":"为typora配置picgo图床","content":"\n\n\n\n下载picgo, 安装gitee-uploader插件(需要node和gitee)\n\n\n配置typora, 验证是否上传成功\n\n\n","slug":"为typora配置picgo图床","date":"2022-02-07T11:41:22.000Z","categories_index":"鼓捣","tags_index":"markdown","author_index":"CYR"},{"id":"56058150d2bcbe6ceb19c55c69837c03","title":"我正在看或者看过的书/课程","content":"\n\n计算机基础中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程\n编程语言【C语言】翁恺C语言程序编程全系列\n黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难\n人工智能《PyTorch深度学习实践》完结合集by刘二大人\n辩论武汉大学：辩论-说服的艺术\n","slug":"lectures","date":"2022-02-07T10:19:01.000Z","categories_index":"学习资料","tags_index":"推荐","author_index":"CYR"},{"id":"bc63bc65f17b60fc9f8b331c18e4940c","title":"利用Hexo搭建个人博客","content":"\n\n步骤\n在Node.js (nodejs.org)下载安装包并按默认设置安装\n\n建立github仓库, 仓库名位username.github.io, username必须与github账户名相同\n\n安装hexo cnpm install -g hexo-cli\n\n创建博客根目录(任意位置)如hexoblog, 命令行中进入hexoblog, 安装hexo-deployer-git cnpm install --save hexo-deployer-git\n\n修改hexoblog/_config.yml中deploy项\n deploy:\n  type: git\n  repo: https:&#x2F;&#x2F;github.com&#x2F;AnDeltas&#x2F;username.github.io.git\n  branch: master\n\n\n执行hexo g: 生成web页面\n执行hexo d推送到远端\n访问username.github.io\n\n常用命令参考官方文档: Documentation | Hexo\n更换主题clone到themes文件夹, 修改_config.yml文件即可\n报错解决\n代理问题:\n 设置代理\ngit config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:1080\ngit config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:1080\n\n\n取消全局代理：\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\nhexo d提交失败可以删除.deploy_git文件夹重试\n\ngit没有设置过用户名和邮箱\n git config --global user.name &quot;username&quot;\ngit config --global user.email &quot;email&quot;\n\n\n\n","slug":"hexo博客搭建","date":"2022-02-07T04:00:00.000Z","categories_index":"鼓捣","tags_index":"hexo","author_index":"CYR"}]